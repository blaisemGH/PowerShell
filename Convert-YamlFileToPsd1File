Function Convert-YamlFileToPsd1File {### Converts a file from .yaml to .psd1 --> Just got it working. Need to clean up code and remove file output requirement.
	Param(
		[Parameter(Mandatory)]
		[string]$yamlFile
	)
	$lineCount = 0
	$prevIndentCount = 0
	$indentTracker = [Collections.Generic.Stack[string]]@()
	$collectionTracker = [Collections.Generic.Stack[string]]@()

	$outFileContents = Get-Content (Resolve-Path $yamlFile) | % {
		$lineCount += 1 # Track line number for descriptive error messages.
		If ( $_ -match '[\S]' -and $_ -notmatch '^[\s]*#' ) {
			$line = $_

			#Define indenting standard at the first indented line. Apply this standard for the rest of the file.
			If ( !$indentType -and $line -match '^\s') {
				$indentType, $indentTypeName, $replaceDash = & {
					If ( $line -match '^\t' ) {
						([char]9).ToString(), 'tab', ''
					}
					Elseif ( $line -match '^ ' ) {
						([char]32).ToString(), 'space', ' '
					}
				}
			}
			Elseif ( $indentType -and $line -match '^\s' -and $line -notmatch "^$indentType") {
				Throw "Document identified first indent uses $indentTypeName indentation, but current line indentation does not. Please use consistent indentation characters on line $lineCount"
			}

			# region parse indent depth
				# indentBase = all the indentation before the actual string text (a leading - is treated as whitespace or null depending on $indenType
				# lineContent = the entire line starting at the string, i.e., without indentBase
				$indentBase	= (($line -replace '-(\s)',"$replaceDash`$1") -split '[^\s]')[0]
				$lineContent = & {
					If ( $indentBase ) {
						(($line -replace '-(\s)',"$replaceDash`$1") -split $indentBase)[1]
					}
					Else {
						$line
					}
				}
	
				# Assemble useful variables for handling indents and outdents below.
				If ( $indentTracker.Count -eq 0 ) {
					$indentPeek = $null
					$previousIndentCount = 0
				}
				Else {
					$indentPeek = $indentTracker.Peek()
					$previousIndentCount = ($indentPeek -split $indentType.ToString()).Count - 1
				}
				If ($indentType) {
					$indentCount = ($indentBase -split $indentType).Count - 1
				}
				Else {
					$indentCount = 0
				}
			# end region parse indent depth

			# region parse line content

				$isNotArrayElement = $false
				$Matches = $null
				
				# Build Matches variable. The regex matches lines of the form <'key': >, <"key": >, <key: >
				[void]([Regex]::Escape($lineContent) -match '(^[''][^'']*['']:)|(^["][^"]*["]:)|(^[^''"]+:) ?')
				$lineKeyPreFormat = If ( $Matches ) {
					(($Matches[0] -split ':')[0] -replace '([^\s]+):(?:([\\ ]|[\\ ][\\ ]))(.*)','$1 = $2').Trim('\ ')
				}
				# when there is no regex match, i.e., it's a <- "list element"> line.
				Else {
					$null
				}
				
				# Adds single quotes if the key contains a -, _, or . and there aren't already quotes in the key name
				$lineKey = $lineKeyPreFormat -replace '^([^''"]?[^''"]*[-_.][^''"]*)$','''$1'''
				
				# Extracts the value, and if the value is a []-enclosed list, replace it with PS-array syntax.
				$lineValue = ($lineContent -replace $lineKeyPreFormat).Trim(': ') -replace '^\[', '@(' -replace '\]$', ')'

				# Wrap quotes on the value if it's not an int or float and doesn't already contain any quotes in its string.
				if ( $lineValue -isnot [int] -and $linevalue -isnot [double] ) {
					$lineValue = $lineValue -replace '^([^''"][^''"]*[^''"])$', '''$1'''
				}
				# For all lines of kv-pairs...
				If ( $lineKey ) {
					If ( $lineValue -eq $lineContent ) { #If the key, value, and original line are all the same, something went wrong.
						Throw "Cannot parse key:value pair. Attempt to separate left and right of the colon yielded the same value as the original line. Line $lineCount"
					}
					# Define that this line is not a list element for parsing below
					$isNotArrayElement = $true
					# Assemble output line to print at the end of this loop ( later code will handle the dict/list delimitations first )
					$outputLine = $indentBase + $lineKey + ' = ' + $lineValue
				}
				# For all lines that aren't kv-pairs. i.e., list elements...
				# Need to refactor into a single codeblock for $outputLine.
				Else {
					# Remove the leading - and any leading whitespace before the strings
					$outputLine = ($line -replace '\s*-\s*').Trim()

					# If the line doesn't have any quotes in it, add them. If they aren't able to be added, throw an error.
					If ( $outputLine -notmatch '^[''"].*[''"]$' ) {
						If ( $outputLine -notmatch '[''"]' ) {
							$outputLine = $indentBase + "'" + $outputLine + "'"
						}
						Else {
							Throw "Cannot validate line. List element not wrapped in single or double quotes! Line $lineCount"
						}
					}
				}
			# end region parse line content

			# region handle new outdent
				If ( $indentCount -lt $previousIndentCount -and $indentTracker.Count -gt 0) {
					# Loop through all the possible outdents, since yaml files can outdent multiple levels from one line to the next.
					While ($indentBase -ne $indentTracker.Peek() ) {
						# If I run out of indents, then something must be off with the indentation
						If ( $indentTracker.Count -eq 0 ) {
							Throw "Indentation not in alignment with previous lines! Line $lineCount"
						}
						[void]$indentTracker.Pop()
	
						# I need to refactor this as it doesn't make sense with the validation above.
						$closeIndentPeek = & {
							If ( $indentTracker.Count -gt 0 ) {
								$indentTracker.Peek()
							}
							Else {
								$null
							}
						}
						Write-Output $(
							Switch ( $collectionTracker.Peek() ) {
								'@(' { $closeIndentPeek + ')' }
								'@{' { $closeIndentPeek + '}' }
								'@(@{' { $closeIndentPeek + '})' }
							}
						)

						[void]$collectionTracker.Pop()
						If ( $indentTracker.Count -eq 0 ) { break }
					}
	
				}
			# end region handle new outdent

			# region handle new indent
				ElseIf ( $indentCount -gt $previousIndentCount ) {

					# For non-list lines
					If ( $line -notmatch '^\s*-' ) {
						$collectionTracker.Push('@{')
						Write-Output ($indentPeek + $collectionTracker.Peek() )
					}
					# For list lines, but only for lists of key-value pairs. Non-kv pairs are handled below currently. May be possible to refactor.
					Else {
						if ( $isNotArrayElement ) {
							Write-Output ( $indentPeek + '@(@{' )
							$collectionTracker.Push('@(@{')
						}
					}

					[void]$indentTracker.Push($indentBase)
				}
			# end region handle new indent

			# region handle open collections
			# --> in particular opening and closing yaml lists
				If ( $line -match '^\s*-' ) { # Lines starting with a -. Handles same indent and outdents; indents are done above.
					If ( $collectionTracker.Peek() -match '^@\(' -and $isNotArrayElement -and $indentCount -le $previousIndentCount) {
						If ( $collectionTracker.Peek() -match '^@\(@\{' ) {
							Write-Output ( $indentPeek + '};@{'  ) # close list element of key-value pairs and open new list element of kv pairs.
						}
						Else { # Not sure if this block is still necessary.
							Write-Output ( $indentPeek + ')' )
							[void]$collectionTracker.Pop()
						}
					}
					# Open new list, or if it's a kv pair, open it --> this latter condition may not be necessary
					If ( $collectionTracker.Peek() -notmatch '^@\(' -or $isNotArrayElement ){
						If ( $collectionTracker.Peek() -notmatch '^@\(@\{' ) {
							Write-Output ( $indentPeek + '@(' )
							$collectionTracker.Push('@(')
						}
					}
				}
	
				Write-Output $outputLine
			# End region handle open collections
		}
	}
	# For when the file ends on a bunch of outdents
	$closeOpenCollections = & {
		ForEach ( $collection in $collectionTracker.ToArray().Clone() ) {
			If ($indentTracker.Count -eq 0 ) {break}
			[void]$indentTracker.Pop()
			$endCloseIndentsPeek = & {
				If ( $indentTracker.Count -gt 0 ) {
					$indentTracker.Peek()
				}
				Else {
					$null
				}
			}
			Switch ( $collectionTracker.Peek() ) {
				'@(' { $endCloseIndentsPeek + ')' }
				'@{' { $endCloseIndentsPeek + '}' }
				'@(@{' { $endCloseIndentsPeek + '})'}
			}
			[void]$collectionTracker.Pop()
		}
	}

	Finish the final output contents, appending a } and prepending a @{ to the entire file, as required by a psd1 file.
	$outFileContents += $closeOpenCollections
	$outFileContents += ([Environment]::NewLine + '}')
	$outFileContents[0] = '@{' + [Environment]::NewLine + [Environment]::NewLine +	$outFileContents[0]

	$outFile = New-TemporaryFile
	Add-Content -Path $outFile -Value $outFileContents
	Return $outFile
}
